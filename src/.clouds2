export const canvas =
  (document.getElementById("canvas") as HTMLCanvasElement) ??
  new HTMLCanvasElement()
export const ctx = canvas.getContext("2d") ?? new CanvasRenderingContext2D()

let rect = canvas.getBoundingClientRect()

// increase the actual size of our canvas
const width = (canvas.width = rect.width * devicePixelRatio)
const height = (canvas.height = rect.height * devicePixelRatio)

// ensure all drawing operations are scaled
ctx.scale(devicePixelRatio, devicePixelRatio)

const paintBackground = () => {
  ctx.beginPath()

  ctx.moveTo(0, 0)
  ctx.lineTo(0, height)
  ctx.lineTo(width, height)
  ctx.lineTo(width, 0)
  ctx.lineTo(0, 0)

  ctx.fillStyle = "#9bd2f8"
  ctx.fill()

  ctx.closePath()
}

paintBackground()

class Utils {
  static map(
    v: number,
    a1: number,
    b1: number,
    a2: number,
    b2: number
  ): number {
    return ((v - a1) / (b1 - a1)) * (b2 - a2) + a2
  }

  static int(n: number): number {
    return Math.floor(n)
  }

  static getRandomArbitrary(min: number, max: number): number {
    return Math.random() * (max - min) + min
  }

  static getRandomInt(max: number): number {
    return Utils.int(Math.random() * max)
  }

  static distance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.hypot(x1 - x2, y1 - y2)
  }

  static rectanglesIntersect = (
    minAx: number,
    minAy: number,
    maxAx: number,
    maxAy: number,
    minBx: number,
    minBy: number,
    maxBx: number,
    maxBy: number
  ) => {
    const aLeftOfB = maxAx < minBx
    const aRightOfB = minAx > maxBx
    const aAboveB = minAy > maxBy
    const aBelowB = maxAy < minBy

    return !(aLeftOfB || aRightOfB || aAboveB || aBelowB)
  }
}

class Fluff {
  x: number
  y: number
  r: number

  constructor(x: number, y: number, r: number) {
    this.x = x
    this.y = y
    this.r = r
  }
  static calcPositionLeft = (prev: Fluff, r: number) => {
    const r1 = prev.r
    const r2 = r
    const hLine = Utils.getRandomInt(prev.r / 1.5)

    const a = r1 - r2 - hLine
    const h = r1 + r2
    const b = Math.sqrt(h * h - a * a)
    const x1 = prev.x
    const y1 = prev.y

    const x2 = x1 - b
    const y2 = y1 + a
    const newFluff = new Fluff(x2, y2, r2)
    return newFluff
  }

  static calcPositionRight = (prev: Fluff, r: number) => {
    const r1 = prev.r
    const r2 = r
    const hLine = Utils.getRandomInt(prev.r / 1.5)

    const a = r1 - r2 - hLine
    const h = r1 + r2
    const b = Math.sqrt(h * h - a * a)
    const x1 = prev.x
    const y1 = prev.y

    const x2 = x1 + b
    const y2 = y1 + a
    const newFluff = new Fluff(x2, y2, r2)
    return newFluff
  }
  draw = (offset: number) => {
    ctx.moveTo(this.x + offset, this.y)
    ctx.arc(this.x + offset, this.y, this.r, 0, Math.PI * 2)
  }
}

class Cloud {
  fluffs: Fluff[]
  x1: number
  x2: number
  y1: number
  y2: number
  speed: number
  colour = "#fffc"
  offset = 0
  constructor(
    fluffs: Fluff[],
    x1: number,
    x2: number,
    y1: number,
    y2: number,
    speed: number
  ) {
    this.fluffs = fluffs
    this.x1 = x1
    this.x2 = x2
    this.y1 = y1
    this.y2 = y2
    this.speed = speed
  }
  static generateFluff = (): Cloud => {
    const { width, height } = rect
    const minSizebigFluff = (width + height) / 40
    const maxSizebigFluff = (width + height) / 30

    const fluffs: Fluff[] = []

    const bigFluff = {
      x: Utils.getRandomInt(width),
      y: Utils.getRandomInt(height),
      r: Utils.int(Utils.getRandomArbitrary(minSizebigFluff, maxSizebigFluff)),
    }
    const minSize = bigFluff.r / 3
    const maxSize = bigFluff.r
    let prevFluffLeft = new Fluff(bigFluff.x, bigFluff.y, bigFluff.r)

    const amountOfFluff = Utils.int(Utils.getRandomArbitrary(1, 3))
    let prevFluffRight: Fluff = prevFluffLeft
    fluffs.push(prevFluffRight)
    for (let index = 0; index < amountOfFluff; index += 2) {
      let fluffLeft = Utils.getRandomArbitrary(minSize, maxSize)
      let fluffRight =
        index + 1 < amountOfFluff
          ? Utils.getRandomArbitrary(minSize, maxSize)
          : 0
      const rand = Math.random()
      if (rand < 0.5) {
        fluffLeft = fluffLeft + fluffRight
        fluffRight = fluffLeft - fluffRight
        fluffLeft = fluffLeft - fluffRight
      }
      // calculate x and y of left fluff
      const newFluffLeft = Fluff.calcPositionLeft(prevFluffLeft, fluffLeft)
      fluffs.unshift(newFluffLeft)
      prevFluffLeft = newFluffLeft

      //calculate x and y of right fluff
      const newFluffRight = Fluff.calcPositionRight(prevFluffRight, fluffRight)
      fluffs.push(newFluffRight)
      prevFluffRight = newFluffRight
    }

    const furthersYValue = fluffs.reduce((prev, curr) => {
      return Math.max(prev, curr.y + curr.r)
    }, 0)

    const smallestYValue = fluffs.reduce((prev, curr) => {
      return Math.min(prev, curr.y - curr.r)
    }, height)

    const createEndFluffLeft = () => {
      const firstFluff = fluffs[0]
      const diam = Math.max(minSize * 2, furthersYValue - firstFluff.y)
      const r = diam / 2
      const x = Fluff.calcPositionLeft(firstFluff, r).x
      const y = furthersYValue - r
      const offsetDistance =
        Utils.distance(firstFluff.x, firstFluff.y, x, y) - (firstFluff.r + r)
      const fluffLeft = new Fluff(x + offsetDistance, y, diam / 2)

      fluffs.unshift(fluffLeft)
    }

    const createEndFluffRight = () => {
      const lastFluff = fluffs[fluffs.length - 1]
      const diam = Math.max(minSize * 2, furthersYValue - lastFluff.y)

      const r = diam / 2
      const x = Fluff.calcPositionRight(lastFluff, r).x
      const y = furthersYValue - r
      const offsetDistance =
        Utils.distance(lastFluff.x, lastFluff.y, x, y) - (lastFluff.r + r)
      const fluffRight = new Fluff(x - offsetDistance, y, r)

      fluffs.push(fluffRight)
    }

    createEndFluffLeft()
    createEndFluffRight()

    const furthersXValue = fluffs.reduce((prev, curr) => {
      return Math.max(prev, curr.x + curr.r)
    }, 0)

    const smallestXValue = fluffs.reduce((prev, curr) => {
      return Math.min(prev, curr.x - curr.r)
    }, height)

    const y1 = smallestYValue
    const y2 = furthersYValue
    const x1 = smallestXValue
    const x2 = furthersXValue
    const speed = Math.random() /100; // Speed of movement

    return new Cloud(fluffs, x1, y1, x2, y2, speed)
  }
  draw = () => {
    ctx.beginPath()

    // Draw all the fluffs
    this.fluffs.forEach((fluff) => fluff.draw(this.offset))

    // Draw the cloud outline and bottom line
    this.drawCloudOutline(ctx)

    // Apply shadow and gradient fill
    // this.applyShadow(ctx, rect.height, canvas.height)
    ctx.fillStyle = this.colour

    ctx.fill()
  }

  private drawCloudOutline(ctx: CanvasRenderingContext2D) {
    ctx.moveTo(this.fluffs[0].x + this.offset, this.y2); // Start from the first fluff at the bottom line
    this.fluffs.forEach((fluff) => ctx.lineTo(fluff.x + this.offset, fluff.y)); // Draw lines connecting each fluff
    ctx.lineTo(this.fluffs[this.fluffs.length - 1].x + this.offset, this.y2); // Connect the last fluff to the bottom line
  }

}

const cloudList: Cloud[] = []

const checkIntersects = (cloud: Cloud) => {
  const ret = cloudList.reduce((intersects, prev) => {
    const inter = Utils.rectanglesIntersect(
      prev.x1,
      prev.y1,
      prev.x2,
      prev.y2,
      cloud.x1,
      cloud.y1,
      cloud.x2,
      cloud.y2
    )
    return intersects || inter
  }, false)
  return ret
}

const checkOutOfBounds = (cloud: Cloud) => {
  const { width, height } = rect
  const middlex = (cloud.x1 + cloud.x2) / 2
  const middley = (cloud.y1 + cloud.y2) / 2
  return middlex < 0 || middlex > width || middley < 0 || middley > height
}

for (let i = 0; i < 8; i++) {
  let cloud = Cloud.generateFluff()
  let attempts = 0
  while ((checkIntersects(cloud) || checkOutOfBounds(cloud)) && attempts < 20) {
    attempts++
    cloud = Cloud.generateFluff()
  }
  cloudList.push(cloud)
}

cloudList.forEach((cloud) => {
  cloud.draw()
})

// Animation loop
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  paintBackground()
  cloudList.forEach((cloud) => {
    // cloud.fluffs.forEach((fluff) => {
    //   fluff.x += cloud.speed
    //   if (fluff.x + fluff.r > width) {
    //     cloud.colour = "black"
    //   }
    // })
    if (cloud.fluffs[0].x - cloud.fluffs[0].r + cloud.offset > width) {
      cloud.offset = -width
    }

    cloud.offset += cloud.speed
    cloud.draw()
  })
  requestAnimationFrame(animate)
}

// Start animation
animate()
